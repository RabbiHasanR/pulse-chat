

# ðŸ“– Real-Time Presence & Chat Consumer Workflow

## **1. Overview**

The `UserSocketConsumer` is the **central nervous system** of your real-time chat application. It manages a persistent WebSocket connection for every active tab or device a user has open.

**Key Features:**

1. **Multi-Device Synchronization:** Handles users connected via multiple tabs (Chrome, Firefox) or devices (Mobile, Desktop) simultaneously.
2. **Global Online/Offline Status:** A user is "Online" if they have *at least one* active connection.
3. **Context-Aware Read Receipts:** Tracks exactly which conversation a user is looking at to trigger "Blue Ticks" instantly.
4. **Typing Indicators:** Real-time feedback when a user is typing.
5. **Smart Notifications:** Uses Pub/Sub to notify friends only when status changes.

---

## **2. Architecture Diagram**

* **Django Channels:** Manages the persistent WebSocket connections.
* **Redis (Sets):** Stores the list of active socket IDs (`channel_name`) for each user.
* **Redis (Pub/Sub):** Used to broadcast "User X is Online" events to their friends.

---

## **3. How Redis is Connected**

The consumer uses `server/utils/redis_client.py` to talk to Redis. We use **Redis Sets** because they automatically handle uniqueness (adding the same ID twice does nothing) and counting.

| Redis Key Pattern | Type | Purpose |
| --- | --- | --- |
| `user:{id}:connections` | **Set** | Stores the unique `channel_name` of every active tab. <br>

<br>*(Size > 0 = Online)* |
| `user:{id}:viewing:{target_id}` | **Set** | Stores `channel_name` of tabs looking at a specific chat. <br>

<br>*(Size > 0 = Message Read Instantly)* |
| `user:{id}:presence_audience` | **Set** | List of User IDs who should be notified when this user goes Online/Offline. |

---

## **4. Detailed Workflow**

### **A. Connection Lifecycle (The "Handshake")**

When a user opens your app:

1. **Auth Check:** The consumer checks `self.scope['user']`. If anonymous, it sends an error and closes.
2. **Group Join:** The socket joins the room `user_{id}`. This is the "mailbox" where the server can send this specific user push notifications.
3. **Redis Registration:**
* The unique socket ID (`self.channel_name`) is added to `user:{id}:connections`.
* **Logic:** `SCARD` (Set Cardinallity) checks the size of the set.
* **Result:**
* If Count == 1: This is the **First** device. **User is Online**.  Trigger "Online" notification.
* If Count > 1: User was already online on another device. Do nothing silent.





### **B. The "Chat Open" Event (Read Receipts)**

When the user clicks on a conversation with "User B":

1. **Frontend:** Sends `{ "type": "chat_open", "receiver_id": 5 }`.
2. **Consumer:**
* Checks if this tab was viewing a different chat previously. If so, removes it from that list.
* Adds `self.channel_name` to `user:{me}:viewing:{5}`.


3. **Result:** If User B sends a message now, the backend checks this Redis key. If it exists, the message is marked **READ** instantly.

### **C. The "Chat Close" Event**

When the user navigates back to the chat list or minimizes the app:

1. **Frontend:** Sends `{ "type": "chat_close", "receiver_id": 5 }`.
2. **Consumer:** Removes `self.channel_name` from `user:{me}:viewing:{5}`.
3. **Result:** Subsequent messages will be "Delivered" (Grey Ticks), not "Read" (Blue Ticks).

### **D. Disconnection (Closing a Tab)**

When the user closes the tab:

1. **Cleanup Viewing:** If they were looking at a chat, remove `channel_name` from the viewing set.
2. **Cleanup Connection:** Remove `channel_name` from `user:{id}:connections`.
3. **Offline Logic:**
* Redis counts the remaining connections.
* If Count == 0: This was the **Last** device. **User is Offline**.  Trigger "Offline" notification.



---

## **5. Code Explanation (How it works)**

### **The Magic of `channel_name**`

In the code, you will see `self.channel_name`.

* **What is it?** A random string generated by Django Channels (e.g., `specific.Active.92831...`).
* **Why use it?** It uniquely identifies **THIS specific tab**.
* **How it replaces `tab_id`:** Since the server generates it, we don't need the client to send a UUID. It's secure and collision-proof.

### **Key Methods in `UserSocketConsumer**`

* **`connect()`**: The entry point. Sets up the Redis state and joins the Channel Group.
* **`_handle_chat_open(data)`**: Updates the "Viewing" Redis Set. Critical for blue ticks.
* **`_notify_my_audience(status)`**: Loops through the `presence_audience` Redis set and sends a WebSocket message to every friend saying "I am now Online/Offline".
* **`disconnect()`**: The cleanup crew. Ensures no "ghost" connections remain in Redis.

---

## **6. API Event Contract (Frontend Docs)**

### **Outbound (Server  Client)**

| Event Type | Payload Example | Meaning |
| --- | --- | --- |
| `presence_update` | `{ "user_id": 5, "status": "online" }` | Update the green dot in your UI for this user. |
| `chat_typing` | `{ "sender_id": 3, "receiver_id": 1 }` | Show "User 3 is typing..." animation. |

### **Inbound (Client  Server)**

| Event Type | Payload Example | When to send |
| --- | --- | --- |
| `chat_open` | `{ "type": "chat_open", "receiver_id": 5 }` | User enters the chat screen. |
| `chat_close` | `{ "type": "chat_close", "receiver_id": 5 }` | User leaves the chat screen. |
| `chat_typing` | `{ "type": "chat_typing", "receiver_id": 5 }` | User is typing in the input box. |
| `ping` | `{ "type": "ping" }` | Every 30s to keep connection alive. |